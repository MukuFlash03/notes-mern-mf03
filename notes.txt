MERN Full Stack Web App Tutorial
- https://www.youtube.com/watch?v=FcxjCPeicvU

-----------------------------------
04/13/23

I. Course Content + Introduction
-------------------------------------

1. CRUD

- Represents four basic operations that can be performed on data in a database or other software system.
    - Create: Add new data.
    - Read: Retrieve existing data.
    - Update: Modify existing data.
    - Delete: Remove existing data.

2. Deployment and Hosting 

- Linode used for website hosting and domain name registration cum acquisition.
- I will try Vercel or GitHub pages.


3. Features of Web App

- Not adding too many features:
  - Add some features and understand concepts clearly

- CRUD operations available on Notes
  - Last updated timestamp provided as well.

- Navigate between sections

- React Bootstrap used for designing app layout
  - Fading long text towards bottom edge of Note
  - Shadow on hover effect

- Responsive UI design
  - Ensure app works on mobile devices as well.

- Authentication: 
    - Login functionality provided to users.
    - Tools used: 
        - Sessions, Cookies instead of JSON Web Tokens (JWTs)
    - Existing User Validation done.


4. MERN Stack

- It is a JavaScript stack used for easier and faster deployment of full-stack web applications.

- MongoDB: 
    - A NoSQL database used to store and manage data stored as key-value pairs in JSON-like documents. 
    - It is a scalable and flexible database that can handle large amounts of data.

- Express: 
    - A web application framework for Node.js that provides a set of features and tools for building web applications. 
    - It is used to handle HTTP requests, define routes, and create APIs.

- React: 
    - A JavaScript library for building user interfaces. 
    - It allows developers to create complex UI components and manage the state of the application efficiently.
    - We will learn about: 
        - React functional components and their reusability,
        - React file and folder structure.
        - Redux state management library.

- Node.js: 
    - A JavaScript runtime environment that allows developers to run backend JavaScript code on the server-side. 
    - It provides a set of modules and tools that make it easy to build server-side applications.


5. TypeScript

- Using TypeScript instead of vanilla JavaScript.
- It is a superset of JS and add a layer on top of JS.
- It is provides strong typing to the language.
- Can be used almost anywhere normal JS can be used.
- For large-scale applications, it is not wise to use JS since variables can have any kind of values and soon everything might blow up.

- Some features not mandatory in TS/JS but better to follow coding conventions used in most languages:
  - Semicolons not needed to terminate lines
  - '' and "" can be used interchangeably, stick to one.


6. Idealogies

A. Not fun to learn from scratch and basics and then build up.
- Better to learn few basics and then dive into projects and learn on the go.
- Google stuff when you require info and gain knowledge by making mistakes, resolving errors.

B. When following a tutorial, don't blindly replicate the end-product.
- Start customizing the project from the start itself.
- Make minor changes as you progress.
- Apply the concepts being taught in the tutorial.


7. React Content Reloading

- React web apps look more like mobile apps.
- This is observed on clicking buttons to navigate to different sections of the app.
- The entire page does not reload but only the content changes.
- This is because React web apps are usually single web pages.
- JS handles static elements and reloads them or brings them into context whenever required.
- Thus React apps require JS to run since JS loads content or data.
- This can be verified when on disabling JS in developer tools, the React app shows an error saying it needs JS to run.

8. Client-side Rendering

- Website loads more data from the server after it is already displayed in the browser
- Next.js used to manage what data to handle on client and server sides.

--------------------------------------------------------


II. Node.js + Express + TypeScript Setup (Hello World)

9. Tools used:

- VS Code
- Node.js


10. Why is Node.js needed?

- It has a usecase since JS is mainly used for writing code for client-side applications.
- Node.js allows writing backend server-side code for building web applications.
- Front-end code can be viewed by programmers as it is exposed via the client-side.
- Hence, to store confidential data programmatically such as credentials, backend server-side code is essential.
- Morever, any sort of form or input validations can be circumvented if their code logic was present in the frontend on the client-side.
- Server-side code is essentially a black box for the outside world and can only be accessed via network requests and that too with appropriate keys or credentials.

------------------

04/16/23

11. Node.js Installation

https://www.youtube.com/watch?v=OMhMnj7SBRQ

- Go to official Node.js website
- Click on "Other Downloads" under LTS version
- Click on "Installing via package manager"
- Click on "Debian/Ubuntu"
- Click on Node.js distributions (GitHub repo)
- Find Ubuntu command:
  $ curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash - &&\ sudo apt-get install -y nodejs


12. Node.js Setup for Project

- Initialize project package.json file
  $ npm init -y
- "-y" : Uses all default values for configuration options


13. TypeScript Installation for Project

$ npm install --save-dev typescript

- Two new files/folders added:
  - package-lock.json: Related to package.json
  - node_modules: Contains dependencies installed for this project

- Here, TS is installed as a "dev dependency" for our current project.
- This addition is reflected in the package.json file as well.
- This means that whenever the project goes into Production, this dependency will be skipped as it is only used by developers to write code.


- Upgrade npm, if required
  $ npm install -g npm@9.6.4


- Generating a TS configuration file (tsconfig.json) that defines how TS should behave
  $ npx tsc --init
- npx vs npm: x -> execute
- tsc: TS Compiler

14. Express Installation

- Shorthand command: i = install
- No --save-dev this time, since this is a normal dependency.
  $ npm i express

- Dev dependency needed for TS to identify types for Express
  $ npm i --save-dev @types/express

- Sometimes dependencies may have been upgraded to newer versions compared to the ones in the tutorial and some errors might occur.
- One option is to check out the official Release Notes for the version and try to implement the changes by yourself
- Another easier option is to install a specific version, such as the one used in the tutorial, run:
  $ npm i express@4.18.2



15. Setting up your first Express server

- Create a new TS file: server.ts
- Import express and create a new server endpoint.
- Assign a port number
  - Some services required specific port numbers, for instance React uses 3000 by default.


- Write a GET endpoint using app.get()
- Start a server using app.listen()


- Start the server using:
  $ node server.ts
- This returns an error since node only knows how to execute JS files.
- To bypass this, TS files must be transmogrified or compiled into JS files using:
  $ npx tsc
- This generates JS files for the corresponding TS files in the pwd.
- Now, execute $ node server.js, which should work:
  - Outputs console message
  - Server should be running and accessible at localhost:5000



16. Code Repository Restructuring + Editing Config Files

- Put all source code TS files into src/

- Add command preference in tsconfig.json to segregate TS-to-JS compiled files from TS files.
  - "outDir": "./dist"
- Stop server
- Reload/re-exeute TS configuration.
  - How did it know that TS files are now under src/ ?
    - It looks in all subdirectories as well and tries to mimic file/folder structure.
- Restart server.

- /dist can be deleted for now since JS files are required at the end once all development has been completed.

- This entire process becomes tedious and repetitive since we need to perform these steps every time we update our TS files(s).
- To automate this process, we will install and use another dev dependency - nodemon
  $ npm i --save-dev nodemon
- However, this depedency only works with JS.
- Thankfully, there's another depedency which compiles TS code to JS on the fly.
  $ npm i -D ts-node
- Shorthand command: -D = --save-dev

- Working of these dependencies:
- To start server:
  $ npx nodemon src/server.ts
- While server is running, any saved changes will be reflected automatically while the server is already running.
  - No need to stop server and restart it.

- To add this commmand as a shorthand command, edit the package.json file to add a new entry "start" under scripts with a value of the command:
  - "scripts": { "start": "nodemon src/server.ts", }
- The server can now be started using:
  $ npm start

- Additionally, update the main entry point of the web app code by giving the path to the JS source code file:
  - "main": "dist/server.js",



17. Install ESLint

- This is used for syntax linting which highlights errors in code.
- Use this command to install ESLint:
  $ npm i -D eslint

- Execute eslint using --init to generate config file - .eslintrc.js
  $ npx eslint --init
- Follow the instructions on the console to install ESLint with required specifications:
  - Syntax + Problems
  - JS modules
  - None of the above frameworks (Using Node.js)
  - TS Yes!
  - Code Run environment: Node.js
  - JS Config file
  - Yes
  - Npm

- ESLint config file:
  - Code environment set to browser despite select node; change it.


18. ESLint Usecases

- For instance, assigning "undefined" Port number is not a good practice.
- Append a '!' to the port parameter in app.listen()
- This tells compiler that this value must not be undefined or null.
- Execute ESLint to check TS files in the pwd:
  $ npx eslint . --ext .ts
- This gives a warning message reiterating the aforementioned issue.

- Better to automate this command by adding a script in package.json
  - "lint": "eslint . --ext .ts",
- Execute using $ npm run lint
  - Not using just $ npm lint, like we did for $ npm start.
  - This is because "start" is internally defined as the shorthand for "run start".


19. VS Code Extension for ESLint

- This integrates the functionality into VS Code without the for manual executions to perform code checks.
- Install extension: ESLint (Orange logo)
- Now, IDE itself will point out errors/warnings.


20. Add a .gitignore file

- Copy the contents from the standard Node-gitignore file from GitHub
  - https://github.com/github/gitignore/blob/main/Node.gitignore
- node_modules not required.
- Config files required to maintain a common standard between project team members (developers)



05/24/23


21. Are we building a RESTful API? If not, what's the difference between our server and a REST API?

- REST APIs usually accessed by many clients
- Hence they also fulfill certain constraints
- For instance, they do not contain states
- However, our server will contain states since for each user's login, there will be a session in the database that connects this user and lets the server know that this user is logged in
- In contrast, we can also build a public REST API using the same endpoints, configurations from this project that serves data to multiple clients. 



III. MongoDB Atlas + Mongoose Setup + Envalid

22. MongoDB

- It will serve as the main database for our app and will store notes as well as user data.
- It is a schema-less or relation-less or non-relational DB, in contrast to a relational DB like SQL which has fixed datatypes and schema constraints.
- This means that we can put any data into any document that we want in any combination.


23. MongoDB Atlas

- To host this DB we can either: self-host on our own server or, use a service like MongoDB Atlas which is a hosting provider for MongoDB databases.
- Atlas takes care of many integral issues such as scaling, security, encryption, backup, etc.

- Signup and create a new account.
- Create a new cluster (follow on-screen instructions)
- Connect to the cluster: create a new admin user (first user by default)
- Choose connection type (application)

- Store MongoDB created user credentials in your project directory
- However, these must not be pushed to public git repo.
- Hence store them in a git ignored file, for instance .env
- This is a suitable file to store environment variables which may be configurational which change depending on where we run our server (localhost or internet deployment) and to store DB credentials

- Create a new file .env in the backend server directory
- Add a new variable that stores MongoDB credentials which should be the url string from the MongoDB website.
- Also add the Port number here since this can change between deployments.

- Install the npm package dependency for env
  $ npm i dotenv  


24. Mongoose

- This is an object modeling package that makes it easier to work with MongoDB database.
  $ npm i mongoose

- Import both dotenv and mongoose in our server.ts file.
- Ensure dotenv is imported earliest since environment variables will be available to the application code then.

- Connect to the DB in code using mongoose.connect and use the environment variables defined in .env
- Move the app.listen part inside the mongoose connection then operation which is reached after the connect promise is fulfilled.
- Add a .catch() that displays error message in case of failure.


25. Envalid package

- process.env used to access variables defined inside .env file
- MONGODB_CONNECTION_STR is highlighted as error by ESLint.
- Undefined PORT is accepted but code will not run and ESLint unable to detect this.

- To solve this, Envalid package is used which defines how our environment variables must look as per .env file and then it enforces this schema.
  $ npm i envalid

- util folder created inside src with a file validateEnv.ts
- Pass environment variables from process.env here.
- Export the default function and then import this in the server.ts file with any name as it is exported as default
- Instead of process.env, now use env which refers to the imported package

26. Directory restructuring

- Separate the server code from the database code
- Create a new file app.ts under src
- Move some express, dotenv code to this file and export default app.
- Import app in server.ts

------------------------------------------------------------------------

IV. MongoDB Model Setup + Express error handling + Middleware


27. Defining a Note data object model

- Create a new folder models under src.
- Create a file note.ts that defines the schema or the data model for the note: title, text, timestamp.
- Title and text are to be added as part of the note data model while timestamp can be added outside so that it can be generated by default by Mongoose.
- Then define a new type of Note which is inferred from the note Schema data object model.
- Finally, export the note model by using the above-defined data type and giving the collection a name followed by the variable referring to the note schema data object model.
- Import the Note model with any name since default export is used.


28. Create an endpoint for fetching Notes from MongoDB: Async-Await

- We'll be using "await" which is syntactic sugar for handling promises in JS.
- This is akin to using then, catch blocks but helps avoid the extra nested code.
- Await wasn't used in server.ts when connecting to DB since we cannot use it at the top level in Express by default.
- However, we can use it inside of our endpoint functions code.
- But, we must also add "async" keyword in the endpoint parameters before the arrow function call.
- This is done so that the code knows that the below code is asynchronous and waiting for a promise to be fulfilled.
- This operation may take some time since we need to query the DB and we don't want the rest of the server to wait just for this.

29. Endpoint

- Reusing same get endpoint for Hello World.
- Async-Await used.
- Query the DB using the NoteModel and call find().exec(); exec() returns a promise.
- Then, set the response status to 200 and return a JSON response

30. MongoDB Website UI

- Once server is restarted, the fetch operation is complete.
- The website DB cluster can then be seen to contain a new "notes" collection on browsing to the View Collections tab.
- The name is fetched from the definition in note.ts while exporting the model as a Collection; the name is pluralized automatically.

- The default name of test is assigned.
- To change this, edit the Connection string in .env file -> add DB name before query params.



31. Add Notes Manually

- Do this through the Atlas UI.
- ID is automatically generated for each note.
- Once note is inserted in the DB, it appears on the webpage as well.


32. Error Handling in Express

- Assume something goes wrong: DB is down, bad code written.
- For now, manually throw an exception/error.
- This causes the main webpage to crash, the app to crash, the server goes down, no other endpoints are accessible and nothing works anymore.


- To handle these, use a try-catch block.
- Try block contains code which might possibly lead to errors or cause exceptions.
- Catch block contains code to handle these so that abrupt shutdown of services is avoided.


33. Separate Error Handler

- This code will have to repeated for each endpoint, hence we can define a separate function for error handling, common to all endpoints.
- It will be an arrow function with a specific set of arguments such that Express can recognize it as an Error Handler.
- These parameters are: error, req, res, next
- We need to pass in parameter "error" and state its type as "unknown".
  - Didn't need to mention types of req, res since it is part of GET request and TypeScript is able to infer these two as request and response parameters.
- Req: Request, Res: Response, Next: NextFunction -> All 3 are from the Express package.
- Each route must have a response or we must call next() which forwards requests to the next middleware which is a piece of code that knows how to handle a request.
- Error handler must be the bottommost app.use() code block as next(error) request is forwarded from all one of the above middleware code blocks.
  - Order of evaluations of middleware is from top to bottom.
  - If more middleware blocks exist beyond error handler code block, and they don't have any error handler, then errors thrown by them will crash server.
  - Hence, last block must be error handler, with the specific predefined set of arguments to handle all errors.

34. Add Another Error Handler Middleware

- This one is to handle non-existing endpoints
- Simply call next(Error(message))
- This will forward request to main Error Handler.
- How does it know that it is the error handler for missing endpoints?

------------------------------------------------------------------------


V. Routers, Controllers, Creating Notes


35. Separating Routes and Controllers 

- Create two directories under src: routes, controllers.
- Routes will contain the endpoints: get('/'), get('/viewNotes'), etc.
- Controllers will contain the main code logic pertaining to what happens or what should happen when these endpoints are reached or triggered.

- Code logic should be stored as functions in controllers which are then exported so that they can be imported elsewhere.
- Types need to be declared again; can simply mention "RequestHandler" after function name as an alternative.
- This is from the Express package and automatically helps in inferring types of parameters.

- In routes, import all functions from the controller file and add specific after endpoint in app.get().
- Function declaration passed and not function call.

- App shows undefined error as express app server was defined in app.ts
- To resolve this, create a new express.Router() this time, instead of creating another express() app server.
- Then replace app.get() with router.get().

- Export this router as default.
- In app.ts, import this router and define a new endpoint, api/notes which will fetch notes.


36. Telling Express what data should be accepted

- This is done to filter data sent as messages to the server.
- This is done in the app.ts file.
- Add another middleware that is a function call to express.json() that specifies that we can both retrieve as well as send JSON data when using GET or POST endpoints, respectively.


37. Creating endpoint for adding Notes

- Add new postNotes() function to notes.ts in controllers
- Add corresponding router.post() route with same endpoint as router.get() in notes.ts in routes
- Same endpoint is acceptable as these two are different HTTP methods.

- Fetch title and content from the note request object.
- Inside try block, create a new note using the NoteModel.create(); this returns a Promise by itself hence don't require exec() like we did for find() in getNotes()
- Return status of 201 (new resource created) just to distinguish all different endpoints.

38. Using Postman to send POST requests

- With a web browser we only have access to the server-side code so far, without any client.
- We can only fetch data using GET requests and can't send POST requests.
- For this, we will use a third-party tool called Postman.

- Open up the HTTP requests interface in Postman.
- Enter the localhost URL with the port and appropriate endpoint.
- Select POST request.
- Under Body choose raw and data type as JSON instead of Text.
- Enter the JSON data for the note and click Send.
- You should receive a response JSON and note should be available in MongoDB.
- Additionally, running GET request in Postman also lists all notes which should include latest note.


39. Creating a new GET endpoint to fetch a single note

- Add a new route with path "/:noteid"
  - noteid is a variable which will be read by Express and put into the request object.
- Add the controller logic for this route.
- Fetch noteID from request parameters (req.params).
- Pass this noteID to Mongoose data object model using findById() and exec() to return a promise. 
- Use Postman to send a GET request by appending a note's ID to request URL to test endpoint.


40. Install Morgan package

- This is a logging utility for logging all console messages sent, received by server.
  $ npm i morgan 
- Helpful to log messages to help sort issues in Production.
- Run this to resolve compile error shown initially which adds type declarations for the package to work with TypeScript.
  $ npm i --save-dev @types/morgan

- Add a middleware for Morgan with "dev" passed as parameter.
- This ensure console messages are logged appropriately in a clean manner.


------------------------------------------------------------------------



VI. Express HTTP Error Handling 


41. Install HTTP_Error_Codes package

- This helps with Error Codes and optimize Error Handling
  $ npm i http-errors
  $ npm i -D @types/http-errors   

- Optimize code by not hardcoding status code.
- Use createHttpError to pass status code when throwing error.
- To check type of error, use isHttpError().
- This is not default export hence enclose in {} when importing from http-errors.


42. Improve error messages for Routes

- For missing title, default Mongoose error message is displayed.
- It is hard to read and doesn't have HTTP status code associated with it.


43. Interfaces

- Using these to define data types of fields in our Note JSON requests.
- To define optional data, add a '?' after the field name and before ':'
- Even mandatory fields should have a ? since we can't know if clients actually sent this data or it was empty.
- Now this interface can be used by adding it as data type to controller function.
- RequestHandler has four fields: URL Params, Response Body, Request Body, Request Query.
- We will set 3rd field for Req Body with the interface type and leave the remaining three as unknown.
- Any vs Unknown: The latter is more restrictive.
- Now, both title and content inside the function have a data type other than 'any' as the types are inferred from the interface.


44. Check Missing Title

- Check if title isn't empty.
- Else throw HttpError with status code 400 and appropriate error message.


45. Check If Note Exists

- GET request to fetch note with specific ID must only go through if the note ID exists.
- Else throw HttpError with status code 404 and appropriate error message.

- Length and format of note ID must also be checked, else default status code 500 is returned even if note ID is missing.
- Use mongoose.isValidObjectID()

------------------------------------------------------------------------

VII. Updating and Deleting Notes


46. Updating Notes

- Create another function to update notes in controller/notes.ts.
- Add error handling code by combining noteID and title checks from both GET and POST functions.
- Create interfaces for both URLParams and JSON Note fields.
- Fetch note using ID and update the fields.
- Save updated note using note.save() with await (DB operation).
- Return it with status code 200 as a JSON object.
- Add route in Routes/note.ts with the PATCH HTTP method; patch verb handles resource update operations.


47. Deleting Notes

- Create a function to delete notes in controller/notes.ts.
- Fetch the note using note ID and use similar error handling code.
- No need for interfaces this time.
- Delete note using note.deleteOne() with await (DB operation).
- Use res.sendStatus() this time since with res.status.json(), the JSON part actually sends the request back.
  - However, since no JSON part is present, we must send the status by itself which is done with the sendStatus().

- Facing error on using note.remove(); hence using note.deleteOne().


------------------------------------------------------------------------


VIII. React Setup + Declarative UI


48. Create new React app


- Run create React app command in root directory
  $ npx create-react-app frontend --template typescript

- In react, all dependencies are grouped together and not segregated into dev dependencies and normal dependencies; anyways once build is ready, any dependencies not in use will be stripped away.

- To fix vulnerabilities, any of these might or might not work:
  $ npm audit; $ npm audit fix; $ npm audit fix --force


49. Run React App

- Use this to start React app in localhost port.
  $ npm start
- Can now see blue rotating React logo.
- Changes to the web page can be seen instantaneously.

- .tsx files are a hybrid version of HTML and JS/TS files.
- This is where our main frontend code will be written.


50. React Declarative UI

- React is a declarative UI framework.
- In an imperative UI, we have to micromanage each element in the frontend whenever something changes.
- We have separate HTML and JS files, can identify each element in HTML by using getElementById() in JS files and then change the element's contents.
- This leads to many difficulties as the project grows and not easy to handle bugs.

- In a declarative UI, React takes care of keeping the data in sync with the frontend visual UI elements.
- We just define and declare elements once and updates to contents can occur automatically.
- Also, JSX files use both HTML and JS and hence code logic can be integrated in the same place.
- This also allows us to create reusable components.
- This is the better approach since earlier separation of HTML and JS was separation of technologies rather than concerns.


51. Install React Bootstrap

- Makes it easier to build good-looking UIs.
  $ npm install react-bootstrap bootstrap

- Add import for bootstrap CSS in index.tsx file.
- This file basically initializes our React app.
- It uses public/index.html for this.

- Change basic info like title, etc. in these files.


52. Adding a Button

- In React, we must use a special type of variable for the state of a component so that React knows that it has to redraw the UI with the updated value of the variable.
- We will create a new state with the variable name and function name enclosed in a pair of [].
  -  const [clickCount, setClickCount] = useState(0);
- Assign the value returned by useState(0) to these array variables; 0 defines initial value.

- Add a Button from the React library in the return() code below.
- Bootstrap CSS should be applied automatically.
- Enclose the clickCount variable using {} to display dynamically updated count.
- Write code logic for setCount() function in the Button onClick field.
  
  <Button onClick={() => setClickCount(clickCount + 1)}>
      Clicked Me {clickCount} times!
  </Button>


------------------------------------------------------------------------


IX. Fetching Notes from Backend onto Frontend


53. Notes Model in Frontend

- This model contains all fields that will be visible in the frontend or required for access to unique notes.
- For instance, timestamp not defined explicitly in backend since MongoDB took care of it; however it is required in the Frontend.
- Create a models directory under src and create a new interface for Note inside note.ts file.
- Create a new state for Notes and set the type to created Note interface.


54. UseEffect

- Where do we load notes?
- Cannot add them in return or react App.tsx since this code redraws UI or renders UI everytime.
- We want our notes to be loaded only once when the app starts.

- For this we utilize useEffects with which we can execute side effects outside of the render code.
- We have control over when it executes and how often.


- We must also pass a dependency array to useEffect.
- This array contains variables that trigger useEffect whenever they change.
- If no array passed, useEffect executed on every render.
- If empty array passed, useEffect executed only once.

- Add JSON.stringify(notes) in HTML section.



55. Run app to Test

- Start app in both backend and frontend in different terminals: $ npm start
- Had to change port numbers since same ports can't be used by both.
- Backend: 4000, Frontend: 3000


56. CORS

- Cross-origin Resource Sharing
- Gives some errors.
- This acts as a security mechanism by blocking backend access by the frontend as they are on different addresses/ports.
- Eventually, we will run both frontend and backend on the same URL with the backend server hidden behind several endpoints.
- In React, we can use proxy to make the two components appear to be on the same address.
- Postman was able to access backend data since this security mechanism is enforced by browsers.

- Additionally, it can be seen that everything is executed twice: error messages logged, pop-up alerts, etc.
- This happens because React renders everything twice in development; in production everything done only once.

- To handle CORS, add proxy: URL for backend port to package.json in frontend.
- To handle using npm package core, read documentation; this method will be of use when dealing with public APIs.


------------------------------------------------------------------------


X. React Components + CSS Modules


57. Components for Notes

- Create React components which will define layout for a note.
- React components are all created in the form of functions nowadays; earlier they were created as classes too.
- Create a new directory components in src and a new file Note.tsx.

- We will define an arrow function and default export it.
- Also needed an interface to declare the type of data each Note would receive.
- A good naming convention for the interface is componentProps, where Props refers to the arguments that we pass to our component.


58. Note Cards

- Next, we'll be using Bootstrap React cards to display our notes.
- The args passed to components, i.e., props are similar to states wherein if any changes occur to the objects themselves, React knows that it has to render these again based on their latest values.
- Define a Note Card in HTML format in Note.tsx.
- Add a corresponding Note Card type in the return() of App.tsx in place of JSON.stringify() using notes.map() to convert each note from the notes array into a Card.
- Restructure the note into all fields and use them directly in Note.tsx in components.


59. CSS Modules

- Delete the App.css file and its corresponding imports.
- We'll be keeping index.css as the global CSS file, which is required since some elements need to be set up only once globally.
- Rename it to global.css and update it in its import in index.tsx as well.

- For our note components we'll create a separate CSS to avoid clashes.
- Create a new folder styles in src.
- Move global CSS file here as well; update imports.

- Create Note.module.css file and add two classes .noteCard and .cardText.
- Add these classes to the Card and Card.Text tags respectively.
- HTML tags have classes but JSX/TSX files have classNames since class is a reserved keyword in these languages.



------------------------------------------------------------------------


XI. Finishing the Notes Styling


60. Create Grids

- Change div tag to React's Container tag in App.tsx.
- Use Row tag to add dynamic resizing.
- Use Col tag to create horizontal separation.


- Create another CSS file: NotesPage.module.css.
- Add hover classes.
- To include this, add another property className to interface NoteProps in Note.tsx.
- Pass this to the Note function and include it as another className in the Card tag.


61. Add CSS Hover styling and Overflow handling

- Add box shadows and transitions
- Handle text overflow in Note.module.css


62. Timestamp 

- Add a Card Footer.
- To format date, separate concerns by writing this code in another file: utils/formatDate.ts.
- Then use this with a if-else logic in the Note component.
- Since it is a cheap operation, can be used here directly even though it will be performed on every render.
- Alternatives are to use useEffect, useMemo, etc.


------------------------------------------------------------------------


XII. Create Notes from Frontend


63. Separate HTTP Methods from React

- Create a new directory network and a new file notes_api.ts.
- Move GET endpoint code in useEffect from App.tsx to this file.
- Create two new fetch notes functions.


64. Create Notes function

- Add a new function to create notes in notes_api.ts.
- Create an interface for it.
- Write code for the POST method similar to GET method written in fetchData().
- Some more fields are passed as a part of the POST JSON object.


65. React Form Component to Add Notes

- Create a new file AddNoteDialog.tsx in components.
- Install React snippets (simple) extension.
- Use src to add the AddNoteDialog component.
- Use Modal tags to build the component.

- In App.tsx, create a new state for the component to be shown or not.
- Add it in the Container as well if the state variable is true.
- Doing it this way so that each time the form is cleared, the contents are cleared as well and previous state content is not retained.

- Add a Button to add new notes as well.
- Here, set ShowAddNoteDialog to true using the useState set variable function.


66. Close Button logic

- Create an interface for the AddNoteDialogProps.
- Define onDismiss here; no args and no return data.
- Add this as the arrow function call for onHide under Modal tag.
- Add onDismiss property to AddNoteDialog tag in App.tsx.


67. Input Form

- Create Form Groups under Modal.Body
- 1st group for Form title; 2nd for Form content.
- Modal.Footer contains form submit Button.
- Form property is used to connect the submit button to the form since both are separated and not connected in the React code.

- Using a package so it is easier to manage states in React forms.
  $ npm i react-hook-form
- Hook returns different kinds of data and functions in our form that we use in our form and will have to destructure the variable.

- Add another property to the interface for form save status.
- Add onSubmit function code logic.
- Connect HTML forms to React Form Hook using ellipsis and register().
- Add error handling in case of missing title using errors and isInvalid property.

- Add disabled property to Submit button based on isSubmitting.


68. Add onNoteSaved callback property to App.tsx

- Add this to the AddNoteDialog tag.
- Set the show boolean variable as false.
- Also, set the notes as all the notes plus the latest note.


69. Utility Classes for Button CSS

- These CSS files are created for those components whose styling is already defined for some other component and just need to reuse some styles.
- Add block center class with display as block and margin sizes.
- Add this property to note submit Button in App.tsx.
 

------------------------------------------------------------------------------



XIII. Updating and Deleting Notes from Frontend


70. Delete Notes

- Add a function in notes_api.ts.
- Install the React icons package
  $ npm i react-icons

- Add the icon tag in Note.tsx.
- Import MdDelete; md stands for material design - UI by Google.


- Add property to interface.
- Define this property function callback to occur onClick of delete button.
- Prevent propagation of this click to future events or triggers, for instance when we want to update note.

- Add property callback in App.tsx as well.
- Create a new function for deleting here as well.
- In setNotes use filter to skip the note to be deleted.


71. Add Icon to Add Note Button

- Use the react-icons package.
- FaPlus icon to be added.
- Add flex center class to Button property.



72. Update Notes

- Create function in notes_api.ts.
- This is similar to POST function but with PATCH as the HTTP method.

- Change AddNoteDialog -> AddEditNoteDialog.
- Add new property to interface AddEditNoteDialogProps.
- Edit the onSubmit code logic to include both update existing note and create new note logic.

- Update title in Modal.Title to include both update/create note scenarios.


73. Note Click Operation in UI

- Add another callback function to NoteProps interface in Note.tsx.
- Add it to the onClick property of the note Card tag.

- Add it in App.tsx as well.
- Create a new state for this.
- Add another AddEditNoteDialog tag like the prior one for showAddEditNoteDialog but this time for noteToEdit.


------------------------------------------------------------------------------


XIV. Loading/Error/Empty States


74. Loading and Error States

- Add two new states for these in App.tsx.
- Call set methods for these state variables in try, catch and finally blocks of the getNotes().


- Fragments in React allow us to put multiple HTML tags in places where we are generally allowed to use only one tag.
- Added boolean checks on these states as done earlier.

------------------------------------------------------------------------------


XV. User Authentication with Express Sessions


75. MongoDB Schema for User Sessions

- Need another schema to store login sessions for users.
- Create a file user.ts in backend/models and add some fields to the schema.
- Email and Password have default false so that they are not returned in any JSON response, etc.



76. Endpoint Controllers for SignUp

- Create a file users.ts in backend/controllers.
- Create an interface, function for SignUp.

- For password, use Raw hashed data variable.
- Need to install a hashing encryption package:
  $ npm i bcrypt
  $ npm i -D @types/bcrypt  


77. Endpoint Routes for SignUp

- Create a file users.ts in backend/routes.
- Add signup route.
- Add userRoutes to app.ts as well.


78. Express-Session Package

- For user authentication, we'll use sessions through this package.
  $ npm i express-session
  $ npm i -D @types/express-session  

- Two ways to keep a user logged in: sessions and JWT tokens.
- JWT tokens are hard to use as they are self-contained, i.e., once generated and given to a user, they can always log in with it; there's no way to invalidate an existing JWT token.
- However, invalidating a session after log in is essential, for instance whenever a user changes their password, they should be logged out of all other devices/sessions as well.
- One option is to keep these tokens short-lived and then refresh them again.

- Sessions work by storing a user's key in a cookie and there is a corresponding entry in the DB on your server for each session.
- Then to invalidate the session for the user, simply delete this DB entry.


79. Connect-Mongo Package

- Another package needed to store our session information.
- Recommended to use Redis DB installed on our own server.
- However, for ease-of-use, MongoDB works.
  $ npm i connect-mongo


- Create @types folder and add type declaration here for express-session userId.
- Make changes in tsconfig.json as well.
- ts-node added since it is required tp automatically restart our server and helps recognize the types.


80. Express Session Middleware in app.ts

- Need to add this at the right place before the routes but after the JSON is read.
- Add a session() call and add some fields such as secret which helps assign a cookie that stores a key to identify a user session.
- In .env file, a SESSION variable and assign a random text phrase as the session secret.
- Add to validateEnv.ts as well so that these are available during runtime.
- Cookie duration and other details added.
- Rolling means that as long as user is logged in or logs in within the duration of the cookie time, cookie is refreshed automatically and the user stays signed in.


81. Endpoint Controllers + Route for Login

- Create a function for login similar to signup.
- Explicitly select password and email to be returned from the response as we had set their select field as false in the user model definition.
- Sending message for invalid credentials makes it slightly tougher to bypass security as it is not clear whether username doesn't exist or password is incorrect.


82. Endpoint for Fetching Authenticated User

- This is done so that already logged in user doesn't have to login again within a certain time duration (cookie expiry duration).
- If cookie isn't present, then user isn't authenticated; this happens when cookie expires.
- But if cookie duration not yet over, then user is authenticated.


83. Endpoint for Logout

- GET vs POST: the latter is preferred as we are changing something, some state in the backend on our side.
- Use req.session.destroy to kill sessions.
- Using sendStatus as we are not sending any JSON.
  - I have used status().json() and sending a custom message for logout confirmation.
- This will also clear sessions from DB.



------------------------------------------------------------------------------



XVI. Frontend Authentication


84. 

- 



















 





